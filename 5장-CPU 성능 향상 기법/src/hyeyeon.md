# 학습 목표

- 빠른 CPU를 위한 설계 기법을 학습
- 빠른 CPU를 위한 명령어 병렬 처리 기법을 학습
- RISC와 CISC의 차이에 대해 이해

# 빠른 CPU를 위한 설계 기법

클럭, 멀티코어, 멀티스레드

## 클럭

1. 컴퓨터 부품들은 '클럭 신호'에 맞춰 일사불란하게 움직인다
2. CPU는 명령어 사이클이라는 정해진 흐름에 맞춰 명령어들을 실행한다

-> 클럭 속도가 높아지면 CPU는 명령어 사이클을 더 빠르게 반복할 것이고, 다른 부품들도 그에 발맞춰 더 빠르게 작동할 것이다
-> 실제로 클럭 속도가 높은 CPU는 일반적으로 성능이 좋다, 클럭속도는 CPU 속도 단위로 간주되기도 함

### 클럭 속도

- 1초에 클럭이 몇 번 반복되는지를 나타내는 Hz 단위로 측정함
- 클럭 속도는 일정하지 않다
  - 고성능을 요하는 순간에는 클럭 속도를 높이고, 그렇지 않을 떈 유연하게 낮춤
  - 최대 클럭 속도를 강제로 끌어올리는 방법 : 오버클럭킹
- 클럭 속도를 높인다고 무조건 CPU가 빨라지지는 않음
  - 무작정 높이면 발열문제가 심각해짐

### 코어와 멀티코어

- 명령어를 실행하는 부품 = 코어
- 코어를 여러개 포함하는 CPU = 멀티코어 CPU or 멀티코어 프로세서
- CPU의 연산 속도는 코어 수에 비례해서 증가하지 않음
  - 중요한 것은 코어마다 처리할 명령어들을 얼마나 적절하게 분배하는 냐, 그에 따라서 연산 속도는 크게 달라짐

### 스레드와 멀티 스레드

- 사전적 스레드 의미 = 실행 흐름의 단위
- CPU에서 사용하는 하드웨어 적 스레드와 프로그램에서 사용되는 소프트웨어적 스레드가 있다

#### 하드웨어적 스레드

- 하나의 코어가 동시에 처리하는 명령어 단위
- 이때까지 스레드는 1코어 1스레드 = 명령어를 실행하는 부품 1개와 한 번에 하나씩 명령어를 실행하는 CPU를 가정했음
- 여러 스레드를 지원하는 CPU는 하나의 코어로도 여러 개의 명령어를 동시에 실행할 수 있음 = 멀티 스레드 프로세스 or 멀티 스레드 CPU라고 한다

#### 소프트웨어적 스레드

- 하나의 프로그램에서 독립적으로 실행되는 단위

#### 멀티 스레드 프로세서

- 멀티 스레드 프로세서는 하나의 코어로 여러 명령어를 동시에 처리하는 CPU
- 코어로 여러 명령어를 동시에 처리하도록 만들려면 프로그램 카운터, 스택 포인터, 메모리 버퍼 레지스터, 메모리 주소 레지스터와 같이 하나의 명령어를 처리하기 위해 꼭 필요한 레지스터를 여러개 가지고 있으면 됨
  - 레지스터 세트가 한 개인 CPU는 한 개의 명형어를 처리하기 위한 정보를 기억 할 뿐이지만
  - 레지스터 세트가 두 개인 CPU는 두 개의 명령어를 처리하기 위한 정보들을 기억할 수 있다
- 스레드를 이용해 하나의 코어로도 여러 명령어를 동시에 처리할 수 있다고 했는데,
  - 메모리속 프로그램 입장에서 봤을 떄 한 번에 하나의 명령어를 처리하는 CPU나 다름이 없다
  - 그래서 논리 프로세서라고 부리가도 한다

# 명령어 병렬 처리 기법

빠른 CPU를 만들기 위해 CPU가 놀지 않고 시간을 알뜰하게 쓰며 작동하게 만드는 것도 중요하다

## 명령어 파이프라인

명령어 처리 과정을 클럭 단위로 나누어 보면 </br>

1. 명령어 인출
2. 명령어 해석
3. 명령어 실행
4. 결과 저장 </br>

- 같은 단계가 겹치지지만 않는 다면 CPU는 각 단계를 동시에 실행할 수 있다
- 명령어들을 **명령어 파이프라인**에 넣고 동시에 처리하는 기법을 **명령어 파이프라이닝**이라고 한다
- 특정상황에서 성능 향상에 실패하는 상황을 파이프라인 위험이라고 한다

### 파이프 라인 위험

1. 데이터 위험
   - 명령어 간 데이터 의존성에 의해 발생 (ex. 어떤 명령어는 이전 명령어를 끝까지 실행해야만 비로서 실행 가능)
     - 모든 명령어를 동시에 처리할 순 없음
     - -> 데이터 의존적인 두 명령어를 동시에 실행하려고 하면 파이프라인이 제대로 작동하지 않는 것을 데이터 위험이라고 함
2. 제어 위험
   - 주로 분기 등으로 인한 프로그램 카운터의 갑작스러운 변화에 의해 발생
   - 기본적으로 프로그램 카운터는 현재 실행 중인 명령어의 다음 주소로 갱신됨
   - but, 실행 흐름이 바뀌어 명령어가 실행되면서 프로그램 카운터 값에 변화가 생긴다면 명령어 파이프라인에 미리 가지고 와서 처리 중이었던 명령어는 필요 없어짐
     - -> 이를 제어 위험이라고 함
     - 그리고 이를 위해 사용하는 기술이 분기예측 (프로그램이 어디로 분기할지 미리 예측)
3. 구조적 위험 (자원 위험)
   - 명령어들을 겹쳐 실행하느느 과정에 서로 다른 명령어가 동시에 CPU 부품(ex. ALU, 레지스터)를 사용하려고 할 때 발생

## 슈퍼스칼라

- 파이프라이닝은 단일 파이프라인으로도 구현이 가능하지만, 오늘날 대부분의 CPU에서는 여러 개의 파이프라인을 이용한다
- 이처럼 CPU 내부에 여러 개의 명령어 파이프라인을 포함하는 구조를 슈퍼스칼라라고 한다
- 이 구조로 명령어 처리가 가능한 CPU를 슈퍼스칼라 프로세서 또는 슈퍼스칼라 CPU라고 한다
- 파이프라인 개수에 비례하여 프로그램 처리 속도가 빨라진다
  - BUT, 이런 저런 예상치 못한 문제가 있어 반드시 갯수에 비해지지도 않음
- 하나의 파이프라인을 사용할 때보다 위험 관리가 까다롭다

## 비순차적 명령어 처리 (OoOE)

- 명령어들을 순차적으로 실행하지 않는 기법
- 이제까지 설명한 명령어 파이프라이닝, 슈퍼스칼라 기법은 모두 여러 명령어의 순차적인 처리를 상정한 방법 임
  - 예상치 못한 여러 위험들로 인해 명령어는 곧바로 처리되지 못함
  - 그래서 만약 모든 명령어를 순차적으로 처리하면 예상치 못한 상황에서 명령어 파이프라인은 멈추게 된다
- 명령어를 순차적으로만 실행하지 않고 순서를 바꿔 실행해도 무방한 명령어를 먼저 실행하여 파이프라인이 멈추는 것을 방지하는 기법임

# CISC와 RISC

- CPU가 파이프라이닝과 슈퍼스칼라 기법을 효과적으로 사용하려면 CPU가 인출하고 해석하고 실행하는 명령어가 파이프라이닝 하기 쉽게 생겨야 함
- 그럼 파이프라이닝 하기 쉬운 명령어란?
- 이와 관련해 CPU의 언어인 ISA와 각기 다른 성격의 ISA를 기반으로 설계된 CISC와 RISC를 학습

## 명령어 집합

- CPU가 이해할 수 있는 명령어들의 모음을 명령어 집합 또는 명령어 집합 구조 (ISA)라고 함
  - CPU마다 ISA가 다를 수 있음
  - ISA가 같은 CPU끼리는 서로의 명령어를 이해할 수 있지만, ISA가 다름면 서로의 명령어를 이해하지 못한다
  - 그래서 ISA는 일종의 CPU의 언어인셈

## CISC

- 복잡한 명령어 집합을 활용하는 컴퓨터
- 다양하고 강력한 기능의 명령어 집합을 활용하기 때문에 명령어의 형태와 크기가 다양한 가변 길이 명령어를 활용함
- 메모리에 접근하는 주소 지정 방식도 다양,
- 상대적으로 적은 수의 명령어로도 프로그램을 실행할 수 있음
- 그래서 메모리를 최대한 아끼며 개발해야 했던 시절에 인기가 높았음

### 단점

- 활용하는 명령어가 워낙 복잡하고 다양한 기능을 제공하는 탓에 명령어의 크기와 실행되기 까지의 시간이 일정하지 않음
- 복잡한 명령어 떄문에 명령어 하나를 실행하는 데에 여러 클럭 주기를 필요로 함
- 명령어의 규격화가 어려워 파이프라이닝이 어려움

## RISC

- CISC에 비해 명령어의 종류가 적음
- 짧고 규격화 된 명령어, 되도록 1클럭 내외로 실행되는 명령어를 지향
