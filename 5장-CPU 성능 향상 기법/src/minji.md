# 빠른 CPU를 위한 설계 기법

## 클럭

- 클럭 속도는 헤르츠(Hz) 단위로 측정하며 1초에 클럭이 몇번 반복되는지를 나타냄
- 1GHz = 10^9 Hz = 1초에 49억번 클럭이 반복
- 클럭 속도는 일정하지 않고 필요한 성능에 따라 속도를 조절함
- 오버클럭킹(overclocking): 최대 속도를 강제로 더 끌어올리는 것
- 클럭 속도를 높이면 CPU가 빨라지지만 클럭 속도가 빠르다고해서 무조건 다 좋아지는 것은 아님

<br/><br/>

## 코어와 멀티코어

- 코어: 명령어를 실행하는 부품
  - 전통적인 CPU는 명령어 실행 부품이 하나였지만 기술의 발전을 통해 명령어 실행 부품을 여러개 장착할 수 있게 되었음
- 멀티코어 CPU(멀티코어 프로세서): 코어를 여러 개 포함하고 있는 CPU
- 코어 수와 비례해서 CPU 연산속도가 증가하는 것은 아님
- 코어마다 처리할 명령어를 적절하게 분배하는 것이 중요

<br/><br/>

## 스레드와 멀티스레드

- 스레드: 실행 흐름의 단위
- CPU 에서 사용하는 스레드와 프로그래밍에서 사용하는 스레드는 용례가 다름

### 하드웨어적 스레드

- 하드웨어적 정의의 스레드: 하나의 코어가 동시에 처리하는 명령어 단위
- 멀티스레드 프로세서(멀티스레드 CPU): 하나의 코어로 여러 명령어를 동시에 처리하는 CPU
- 하이퍼스레딩: 인텔의 멀티스레드 기술

### 소프트웨어 스레드

- 소프트웨어적 정의의 스레드: 하나의 프로그램에서 독립적으로 실행되는 단위
- 1코어 1스레드 CPU도 여러 스레드로 만들어진 프로그램을 실행할 수 있음

### 멀티스레드 프로세서

- 하나의 코어로 명령어를 동시에 처리하기 위해 레지스터를 여러개 보유함
- 하드웨어 스레드 수가 한번에 처리할 수 있는 명령어의 단위이므로 프로그램 입장에서는 스레드 수가 마치 CPU의 수와 같아 보임. 따라서 하드웨어 스레드를 논리 프로세서라고도 함

<br/><br/><br/><br/>

# 명령어 병렬 처리 기법(ILP, Instruction-Level Parallelism)

## 명령어 파이프라인

- 명령어 처리 과정: 명령어 인출 -> 명령어 해석 -> 명령어 실행 -> 결과 저장(명령어 인출 -> 명령어 실행으로 표현하거나 실행과 저장 사이 메모리 접근 단계를 넣기도 함)
- 같은 단계가 겹치지 않는다면 CPU 는 각 단계를 동시에 실행할 수 있기에 한 명령어를 인출하는 동안 다른 명령어에 대해 실행할 수 있음
- 명령어 파이프라이닝: 모든 명령어를 순차적으로 처리하는 것이 아니라 명령어를 겹쳐서 수행하도록 명령어 파이프라인에 넣고 동시에 처리하는 기법
- 장점: 높은 성능을 가져옴
- 단점: 파이프라인 위험 상황의 경우 성능 향상에 실패할 수 있음

### 파이프라인 위험1: 데이터 위험

데이터 의존적인 명령어를 동시에 실행하려 하면 파이프라인이 제대로 작동하지 않는 것을 의미함

### 파이프라인 위험2: 제어 위험

프로그램 카운터 값에 갑작스러운 변화가 생겼을 때 명령어 파이프라인에서 미리 처리하고 있던 명령어가 쓸모가 없어지는 것을 의미함

- 이를 위해 사용되는 기술 중 하나가 분기 예측(branch prediction)
- 분기 예측: 프로그램이 어디로 분기할지 미리 예측한 후 그 주소를 인출하는 기술

### 파이프라인 위험3: 구조적 위험(자원 위험)

서로 다른 명령어가 ALU, 레지스터와 같은 CPU 부품을 사용하려고 하는 것을 의미함

<br/><br/>

## 슈퍼스칼라

CPU 내부에 여러 개의 명령어 파이프라인을 포함한 구조를 의미함

- 슈퍼스칼라 프로세서(슈퍼스칼라 CPU): 슈퍼스칼라 구조로 명령어 처리가 가능한 CPU
- 매 클럭 주기마다 동시에 여러 명령어를 인출하거나 실행하는 것도 가능함
- 이론적으로는 파이프라인 개수에 비례해 프로그램 처리 속도가 빨라지지만 파이프라인 위험 등의 문제로 인해 반드시 비례하는 것은 아님

<br/><br/>

## 비순차적 명령어 처리(OoOE, Out-of-Order Execution)

명령어를 순차적으로 실행하지 않고 더 효율적인 처리를 위해 순서를 바꾸는 것 의미함

- 데이터 의존성이 없어서 순서를 바꿔 처리해도 수행 결과에 영향을 미치지 않는 명령어들의 순서를 바꿔 실행함
- 바꿔도 무방한 명령어들을 먼저 실행해 파이프라인이 멈추는 것을 방지함

<br/><br/><br/><br/>

# CISC와 RISC

## 명령어 집합

- 명령어 집합(명령어 집합 구조, ISA, Instruction Set Architecture): CPU 가 이해할 수 있는 명령어들의 모음
- CPU 마다 ISA 가 다를 수 있음
- ISA가 다름 -> CPU가 이해할 수 있는 명령어가 다름 -> 어셈블리어가 다름
- ISA 는 CPU 의 언어이자 하드웨어가 소프트웨어를 어떻게 이해할지에 대한 약속과 같음

<br/><br/>

## CISC(Complex Instruction Set Computer)

- 복잡한 명령어 집합을 활용하는 컴퓨터를 뜻하며, 복잡하고 다양한 명령어들을 활용하는 CPU 설계 방식
- 명령어의 형태와 크기가 다양한 가변 길이 명령어를 활용
- 메모리에 접근하는 주소 지정 방식 다양함
- 아주 특별한 상황에서만 사용되는 독특한 주소 지정 방식이 있음
- 다양하고 강력한 명령어를 활용 -> 적은 수의 명령어로도 프로그램을 실행할 수 있음 -> 컴파일된 프로그램의 크기가 작음
- 장점: 메모리 공간 절약이 가능
- 단점
  - 명령어의 크기와 실행되기까지의 시간이 일정하지 않고 명령어 하나에 여러 클럭주기를 필요로 함 -> 명령어 파이프라인을 구현하는데 큰 어려움이 생김
  - 대다수의 복잡한 명령어는 사용 빈도 수가 낮음

<br/><br/>

## RISC(Reduced Instruction Set Computer)

- CISC 보다 명령어의 종류가 적음
- CISC와 달리 짧고 규격화 되어있으며 되도록 1클럭 내외로 실행되는 명령어를 지향함 -> 고정 길이 명령어 활용
- 메모리에 직접 접근하는 명령어가 load, store 두개로 제한 -> 메모리 접근 단순화 & 최소화 -> 주소 지정 방식 종류가 적음
- 레지스터를 적극 활용하여, CISC 보다 레지스터를 이용하는 연산이 많고, 일반적인 경우보다 범용 레지스터 개수도 더 많음
- 파이프라이닝이 쉬움
