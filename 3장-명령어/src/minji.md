# 소스 코드와 명령어

## 고급 언어와 저급 언어

- 고급언어: 사람을 위한 언어로 대부분의 프로그래밍언어가 이에 속함
- 저급언어: 컴퓨터가 직접 이해하고 실행할 수 있는 언어
  - 기계어: 0과 1의 명령어 비트로 이루어진 언어
  - 어셈블리어: 기계어를 읽기 편한 형태로 번역한 언어

<br/><br/>

## 컴파일 언어와 인터프리터 언어

고급 언어를 저급 언어로 변환하는 방식으로 컴파일 방식과 인터프리트 방식이 있고, 각 방식으로 작동하는 언어를 컴파일 언어, 인터프리터 언어라고 함

### 컴파일 언어

컴파일러에 의해 소스 코드 전체가 저급 언어로 변환되어 실행되는 고급 언어

- ex. C
- 컴파일러: 컴파일을 수행해주는 도구
  - 문법적인 오류는 없는지, 실행 가능한 코드인지, 실행하는데 불필요한 코드는 없는지 등을 따지며 저급 언어로 컴파일함
  - 소스코드에 오류가 하나라도 있다면 컴파일에 실패함
- 목적 코드: 컴파일러를 통해 저급 언어로 변환된 코드

### 인터프리터 언어

인터프리터에 의해 소스 코드가 한 줄씩 실행되는 고급 언어

- ex. Python
- 인터프리터: 소스 코드를 한 줄씩 저급 언어로 변환하여 실행해 주는 도구
  - 소스 코드 전체를 저급 언어로 변환하는 시간을 기다릴 필요가 없음
  - 소스 코드에 문제가 있어도 문제가 있는 줄을 실행하기 전까진 올바르게 수행됨
- 인터프리터 언어가 한 줄씩 저급 언어로 해석하며 실행해야 해서 일반적으로 컴파일 언어 보다 느림

### 컴파일 언어와 인터프리터 언어

- C, C++ 같이 명확하게 구분할 수 있는 언어도 있지만 현대의 많은 프로그래밍 언어는 모호한 경우가 많음
- Python 도 컴파일을 하지 않는 것은 아님
- Java 의 경우 저급 언어가 되는 과정에서 컴파일과 인터프리트를 동시에 수행함

### 목적 파일 vs 실행 파일

- 목적 파일이 실행 파일이 되기 위해서는 **링킹** 이라는 작업을 거쳐야 함
- 링킹: 여러 개의 코드와 데이터를 모아서 연결하는 작업

<br/><br/><br/><br/>

# 명령어의 구조

## 연산 코드와 오퍼랜드

- 명령어는 연산 코드와 오퍼랜드로 구성됨
- 연산 코드(연산자): 명령어가 수행할 연산
- 오퍼랜드(피연산자): 연산에 사용할 데이터 또는 연산에 사용할 데이터가 저장된 위치
- 하나의 명령어는 연산 코드가 담기는 연산 코드 필드와 오퍼랜드가 담기는 오퍼랜드 필드로 구성됨

### 오퍼랜드

- 오퍼랜드 필드엔 숫자와 문자 등의 데이터나 메모리나 레지스터 주소가 올 수 있음
- 대부분 데이터를 직접 명시하기보단 메모리나 레지스터 주소가 오고, 이 때문에 오퍼랜드 필드를 주소필드라고 부르기도 함
- 오퍼랜드의 개수에 따라 0-주소 명령어, 1-주소 명령어, 2-주소 명렁어, 3-주소 명령어라고 구분함

### 연산 코드

- 크게 4가지로 나눌 수 있음: 데이터 전송, 산술/논리 연산, 제어 흐름 변경, 입출력 제어
- 데이터 전송: MOVE, STORE, LOAD(FETCH), PUSH, POP
- 산술/논리 연산: ADD, SUBTRACT, MULTIPLY, DIVIDE, INCRREMENT, AND, COMPARE 등
- 제어 흐름 변경: JUMP(실행 주소 이동), CONDITIONAL JUMP(조건 부합시 특정 주소로 실행 주소 이동), HALT(프로그램 실행 중단), CALL(되돌아올 주소를 저장한 채 특정 주소로 실행 순서 이동), RETURN(CALL 호출할 때 저장한 주소로 돌아가기)
- 입출력 제어: READ(INPUT), WRITE(OUTPUT), START IO, TEST IO

<br/><br/>

## 주소 지정 방식

오프랜드 필드에 데이터가 저장된 위치를 명시할 때 사용할 데이터 위치를 찾는 방법

- 메모리 주소 또는 레지스터 이름을 사용하여 표현할 수 있는 정보 가짓수를 늘리고자 함
- 유효 주소: 연산 코드에 사용할 데이터가 저장된 위치

### 즉시 주소 지정 방식

연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시하는 방식

- 단점: 표현 가능한 데이터 크기가 작아짐
- 장점: 메모리나 레지스터로부터 데이터를 찾지 않아도 되므로 속도가 빠름

### 직접 주소 지정 방식

오퍼랜드 필드에 유효 주소를 직접 명시하는 방식

- 장점: 즉시 주소 지정 방식보다 표현 가능 데이터 크기가 큼
- 단점: 유효 주소 표현 범위가 연산 코드의 비트 수만큼 줄어들어, 표현 가능한 유효 주소에 제한이 여전히 존재함

### 간접 주소 지정 방식

유효 주소의 주소를 오퍼랜드 필드에 명시하는 방식

- 장점: 연산 코드의 비트 수만큼 줄어들지 않아 직접 주소 지정 방식보다 표현 가능 데이터 크기가 큼
- 단점: 두 번의 메모리 접근이 필요해 일반적으로 속도가 느림

### 레지스터 주소 지정 방식

연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드에 직접 명시하는 방식

- 장점: 메모리 접근보다 레지스터 접근이 일반적으로 더 빠르므로, 빠르게 데이터 접근이 가능함
- 단점: 직접 주소 지정 방식처럼 표현할 수 있는 레지스터 크기에 제한이 생길 수 있음

### 레지스터 간접 주소 지정 방식

연산에 사용할 데이터를 메모리에 저장하고, 그 주소를 저장한 레지스터를 오퍼랜드 필드에 명시하는 방식

- 장점: 메모리 접근 횟수가 한 번으로 줄어 간접 주소 지정 방식보다 빠름
