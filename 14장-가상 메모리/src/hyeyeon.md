# 연속 메모리 할당

프로세스에 연속적인 메모리 공간을 할당하는 방식

## 스와핑

당장 실행하지 않는 프로세스 (ex 입출력 대기, 오랫동안 사용되지 않은 것)를 임시로 보조기억장치 일부 영역으로 쫒아내고, 매모리 빈 공간에 또 다른 프로세스를 적재하여 실행하는 방식을 스와핑이라고 한다

- 보조기억장치의 일부 영역 = 스왑영역
- 현재 실행되지 않는 프로세스가 메모리에서 스왑 영역으로 옮겨지는 것 = 스왑 아웃
- 스왑 영역에 있던 프로세스가 다시 메모리로 옮겨오는 것 = 스왑 인
  - 스왑 아웃되기 전 물리 주소와 다른 주소에 적재될 수 있음

스와핑을 이용하면 프로세스들이 요구하는 메모리 주소 공간 크기가 실제 메모리 크기보다 큰 경우에도 프로세스들을 동시에 실행할 수 있다

## 메모리 할당

비어 있는 메모리 공간에 프로세스를 연속적으로 할당하는 방식

### 최초 적합

최초로 발견한 적재 가능한 빈 공간에 프로세스를 배치하는 방식

### 최적 적합

프로세스가 적재될 수 있는 가장 작은 공간에 프로세스를 배치하는 방식

### 최악 적합

프로세스가 적재될 수 있는 가장 큰 공감에 프로세스를 배치하는 방식

## 외부 단편화

연속 메모리 할당은 외부 단편화라는 문제를 내포하고 있다

외부 단편화 : 프로세스를 할당하기 어려울 만큼 작은 메모리 공간들로 인해 메모리가 낭비되는 현상

### 해결방안

대표적으로 메모리를 압축하는 방법이 있다 (메모리 조각 모음)
메모리 내에 저장된 프로세스를 적당히 재배치시켜 여기저기 흩어져 있는 작은 빈 공간들을 하나의 큰 빈공간으로 만드는 방법 </br>

단점

1. 작은 빈 공간들을 하나로 모으는 동안 시스템은 하던 일을 중지해야 함
2. 메모리에 있는 내용을 옮기는 작업은 많은 오버헤드를 야기한다
3. 어떤 프로세스를 어떻게 움직여야 오버헤드를 최소화하며 압축할 수 있는지 명확한 방법을 결정하기 어렵다

# 페이징을 통한 가상 메모리 관리

메모리에 연속적으로 할당하는 방식은 두 가지 문제를 내포하고 있다

1. 외부 단편화
2. 물리 메모리보다 큰 프로세스를 실행할 수 없다

가상 메모리는 실행하고자 하는 프로그램을 일부만 메모리에 적재하여 실제 물리 메모리 크기보다 더 큰 프로세스를 실행할 수 있게 하는 기술
이를 가능케 하는 가상 메모리 관리 기법에는 크게 페이징과 세그멘테이션이 있다

## 페이징이란

연속 메모리 할당 방식에서 외부 단편화가 생긴 이유는 각기 다른 크기의 프로세스가 메모리에 연속적으로 할당되었기 때문
만일 메모리와 프로세스를 일정한 단위로 자르고, 이를 메모리에 불연속적으로 할당할 수 만 있다면 외부단편화는 발생하지 않는다

즉, 페이징은 메모리의 물리 주소 공간을 프레임 단위로 자르고, 프로세스의 논리 주소 공간을 페이지 단위로 자른 뒤 각 페이지를 프레임에 할당하는 가상 메모리 관리 기법임
페이징에서도 스와핑을 사용 할 수 있다
다만, 프로세스 전체가 스와핑되는 것이 아니라 페이지 단위로 된다
페이징 시스템에서 스왑 아웃은 페이지 아웃, 스왑 인은 페이지 인으로 부르기도 함

## 페이지 테이블

그런데 프로세스가 메모리에 불연속적으로 배치되어 있다면 CPU 입장에서 이을 순차적으로 실행할 수 없다 (다음 실행할 명령어 위치를 찾기 어려움)
이를 해결하기 위해 페이징 시스템은 프로세스가 비록 물리 주소에 불연속으로 배치되더라도 논리 주소에는 연속적으로 배치되도록 페이지 테이블을 이용한다

페이지 테이블 : 페이지 번호를 이용해 페이지가 적재된 프레임을 찾을 수 있다

프로세스마다 각자의 페이지 테이블을 가지고 있고 각 프로세스의 페이지 테이블은 메모리에 적재되어 있다
그리고 CPU내의 페이지 테이블 베이스 레지스터 (PTBR) 각 프로세스의 페이지 테이블이 적재된 주소를 가리키고 있다

그런데 이렇게 페이지 테이블을 메모리에 두면 문제가 있다, 메모리 접근 시간이 두 배로 늘어남 (메모리에 있는 페이지 테이블 확인, 프레임에 접근)
이 문제를 해결하기 위해서 CPU 곁에 TLB라는 페이지 테이블의 캐시 메모리를 둔다

- TLB 히트: CPU가 발생한 논리 주소에 대한 페이지 번호가 TLB에 있을 경우
- TLB 미스: 페이지 번호가 TLB에 없을 경우 메모리 내의 페이지 테이블에 접근하는 경우

## 페이징에서의 주소 변환

하나의 페이지는 여러 주소를 포괄하고 있다. 그렇기에 특정 주소 접근하려면 두 가지 정보가 필요

1. 어떤 페이지 혹은 프레임에 접근하고 싶은지
2. 접근하려는 주소가 그 페이지 혹은 프레임으로부터 얼마나 멀리 떨어져 있는지

그렇기에 페이징 시스템에서 모든 논리 주소가 페이지 번호, 변위로 이루어졍 ㅣㅆ다

## 페이지 테이블 엔트리

페이지 테이블의 각 행들을 페이지 테이블 엔트리라고 한다
행에는 프레임 번호 이외에 유효 비트, 보호 비트, 참조비트, 수정 비트 정보가 함께 있다.

### 유효 비트

현재 해당 페이지에 접근 가능한지 여부 표시
페이징에서도 스와핑이 가능하다 그래서 프로세스를 이루는 모든 페이지가 메모리에 있지 않는다
일부 페이지는 보조기억장치에 있는 경우가 많다
유효 비트는 현재 페이지가 메모리에 적재되었는지 아님 보조기억 장치에 있는지 알려주는 비트

만약 적재되지 않는 페이지로 접근하려고 할 때 페이지 폴트가 난다

### 보호 비트

페이지 보호 기능을 위한 비트
해당 페이지가 읽고 쓰기가 가능한 페이지인지 아니면 일기만 해야하는 페이지인지 나타낸다

### 참조 비트

CPU가 이 페이지를 접근 한 적이 있는지 여부를 나타낸다

### 수정 비트

해당 페이지에 데이터를 쓴 적이 있는 지 수정 여부를 알려준다

페이지가 메모리에서 사라질 때 보조 기억 장치에 쓰기 작업으 해야하는지 알려줌

# 페이지 교체와 프레임 할당

## 요구 페이징

페이지가 필요할 때에만 메모리에 적재하는 기법

아무런 페이지도 메모리에 적재하지 않은 채 무작정 실행부터 할 수도 있다. 이 경우 프로세스의 첫 명려어를 실행하는 순간부터 페이즈 폴트가 발생하고, 실행에 필요한 페이지가 어느 정도 적재된 이후부터는 페이지 폴트 발생 빈도가 떨어진다. 이를 순수 요구 페이징이라고 한다.

요구 페이징 시스템이 안정적으로 작동하려면 다음 두가지를 꼭 해결해야한다

1. 페이지 교체
   요구 페이징 기법으로 페이지들을 적재하다 보면 언젠가 메모리가 가득 차게된다. 이때 당장 실행에 필요한 페이지를 적재하기 위해 메모리에 적재된 페이지를 보조기억장치로 내보내야 한다
   메모리에 적재된 페이지 중 어떤 페이지를 내보낼지를 결정하는 방법은 페이지 교체 알고리즘이라고 한다.
2. 프레임 할당

## 페이지 교체 알고리즘

일반적으로 페이지 폴트를 가장 적게 일으키는 알고리즘을 좋은 알고리즘으로 평가한다
페이지 폴트가 일어나면 보조기억장치로부터 필요한 페이지를 가져와야 하기 때문에 메모리에 적재된 페이지를 가져오는 것보다 느려지기 때문

그렇기에 페이지 교체 알고리즘을 제대로 이해하려면 페이지 폴트 횟수를 알 수 있어야 한다
그리고 페이지 폴트 횟수는 페이지 참조열을 통해 알 수 있음

페이지 참조열: CPU가 참조하는 페이지들 중 연속된 페이지를 생략한 페이지열을 의미

### FIFO 페이지 교체 알고리즘

메모리에 가장 먼저 올라온 페이지부터 내쫒는 방식

아이디어와 구현은 간단하지만 페이지가 프로그램 실행 내내 사용될 내용을 포함하고 있으면 먼저 적재되어다고 해서 내쫒으면 안됨

### 최적 페이지 교체 알고리즘

CPU에 의해 참조되는 횟수를 고려하는 알고리즘
앞으로의 사용 빈도가 가장 낮은 페이지를 교체하는 알고리즘

다른 페이지 교체 알고리즘에 비해 페이지 폴트 발생 빈도가 가장 낮지만 실제 구현하기 어려움
그래서 다른 페이지 교체 알고리즘의 이론상 성능을 평가하기 위한 목적으로 사용함

### LRU 페이지 교체 알고리즘

가장 오래동안 사용되지 않은 페이지를 교체 하는 알고리즘

## 스레싱과 프레임 할당

페이지 폴트가 자주 일어나는 이유가 나쁜 페이지 교체 알고리즘에만 있는 건 아님
프로세스가 사용할 수 있는 프레임 수가 적어도 페이지 폴트는 자주 발생한다.
이처럼 프레임이 부족하면 CPU는 페이지 폴트가 자주 발생할 수 밖에 없다.
실행의 맥이 끊기고 결과적으로 CPU의 이용률도 떨아진다.

이처럼 프로세스가 실제 실행되는 시간보다 페이징에 더 많은 시간을 소요하여 성능이 저해되는 문제를 스래싱이라고 한다.
메모리에서 동시 실행되는 프로세스의 수를 멀티프로그래밍의 정도라고 합니다. 멀티 프로그래밍의 정도가 높다면 현재 메모리에는 많은 프로세스가 동시에 실행 중이고, 낮다면 현재 메모리에는 적은 프로세스가 동시에 실행 중이라고 이해하면 된다

동시에 실행되는 프로세스 수가 어느 정도 증가하면 CPU 이용률이 높아지지만, 필요 이상으로 늘리면 각 프로세스들이 사용할 수 있는 프레임 수가 작아지기 때문에 페이지 폴트가 지나치게 비번히 발생한다 이에 따라 CPU 이용률이 떨어져 전체적인 성능이 저해되는 것이다. 아무리 CPU의 성능이 뛰어나도 동시에 실행되는 프로세스를 수용할 물리 메모리가 적다면 전체 컴퓨터의 성능이 안 좋아지는 이유도 그러함

스래싱이 발생하는 근본적인 원인은 각 프로세스가 필요로 하는 최소한의 프레임 수가 보장되지 않았기 때문
그렇기에 운영체제는 각 프로세스들이 무리 없이 실행하기 위한 최소한의 프레임 수를 파악하고 프로세스들에 적절한 수만큼 프레임을 할당해 줄 수 있어야 한다

### 프레임 할당 방식

모든 프로레스에 균등하게 프레임을 제공하는 방식을 균등 할당이라고 한다
프로세스의 크기가 크면 프레임을 많이 할당하고 프로세스 크기가 작으면 프레임을 작게 나눠 주는 방식을 비례 할당이라고 한다.
균등 할당과 비례 할당 방식은 프로세스의 실행 과정을 고려하지 않고 단순히 프로세스의 크기와 물리 데이터의 크기만을 고려한 방식이라는 점에서 정적 할당 방식이라고 한다

하지만 프로세스의 크기가 클지라도 막상 실행해보니 많은 프레임을 필요로 하지 않는 경우도 있다. 반대도 마찬가지
즉, 하나의 프로세스가 실제로 얼마나 많은 프레임이 필요한지는 결국 실행해 봐야 아는 경우가 많다

프로세스를 실행하는 과정에서 배분할 프레임을 결정하는 방식에는 크게 작업 집합 모델을 사용하는 방식과 페이지 폴트 빈도를 사용하는 방식이 있다

스래싱이 발생하는 이유는 빈번한 페이지 교체 때문, 그렇기에 작업 모델 기반 프레임 할당 방식은 프로세스가 일정 기간 동안 참조한 페이지 집합을 기억하여 빈번한 페이지 교첼르 방지한다

실행 중인 프로세스가 일정 시간 동안 참조한 페이지의 집합을 작업 집합이라고 한다
CPU가 과거에 주로 참조한 페이지를 작업 집합에 포함한다면 운영체제는 작업 집합의 크기만큼만 프레임을 할당해 주면 된다
