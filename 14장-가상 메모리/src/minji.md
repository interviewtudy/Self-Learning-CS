# 연속 메모리 할당

프로세스에 연속적인 메모리 공간을 할당하는 방식

## 스와핑

오랫동안 사용되지 않는 프로세스를 보조기억장치 일부 영역으로 쫓아내고 생긴 빈 공간에 다른 프로세스를 적재하는 방식

- 스왑 영역: 프로세스들이 쫓겨나는 보조기억장치의 일부 영역
- 스왑 아웃: 메모리 -> 스왑 영역
- 스왑 인: 스왑 영역 -> 메모리
- 스왑 아웃되었던 프로세스가 다시 스왑 인될 때는 스왑 아웃시 적재되어있던 물리 주소와 다른 주소에 적재 가능
- 스와핑을 통해 프로세스들이 요구하는 메모리 주소 공간의 합이 실제 메모리 크기보다 큰 경우에도 프로세스를 동시 실행할 수 있음

<br/><br/>

## 메모리 할당

- 최초 적합: 운영체제가 메모리의 빈 공간을 순서대로 검색하다가 적재할 수 있는 공간을 발견하면 그 공간에 프로세스를 배치하는 방식
  - 장점: 검색을 최소화 할 수 있고 빠른 할당이 가능함
- 최적 적합: 운영체제가 빈 공간을 모두 검색해본 후 프로세스가 적재될 수 있는 공간 중 **가장 작은** 공간에 프로세스를 배치하는 방식
- 최악 적합: 운영체제가 빈 공간을 모두 검색해본 후 프로세스가 적재될 수 있는 공간 중 **가장 큰** 공간에 프로세스를 배치하는 방식

<br/><br/>

## 외부 단편화

연속 메모리 할당으로 프로세스들이 실행되고 종료됨에 따라 메모리 사이 사이에 빈 공간들이 생기고, 그 공간들보다 큰 프로세스르 적재하기 어려운 상황을 초래해 메모리 낭비로 이어지는 현상

- 메모리 조각 모음(압축): 흩어진 빈 공간을 한 곳으로 모으는 방식으로 프로세스를 적당히 재배치 시켜 하나의 큰 빈 공간을 만듦.
  - 단점: 빈공간을 하나로 모으는 동안 시스템이 하던 일을 중지해야 함. 메모리 내용을 옮기는 작업이 많은 오버헤드 야기. 어떤 프로세스를 어떻게 움직여야 오버헤드를 최소화할 수 있는지 명확한 방법이 없음.
- 페이징 기법: 오늘날까지도 사용되는 가상 메모리 기법

<br/><br/><br/><br/>

# 페이징을 통한 가상 메모리 관리

- 가상 메모리: 실행하고자 하는 프로그램을 일부만 메모리에 적재해 실제 물리 메모리보다 크기가 더 큰 프로세스를 실행할 수 있게하는 기술
- 페이징과 세그멘테이션이 있지만 현대 대부분의 운영체제에서는 페이징 기법을 사용함

## 페이징이란

메모리에 불연속적으로 할당할 수 있게 하여 외부 단편화를 방지하는 방식으로 페이지를 프레임에 할당하는 가상 메모리 관리 기법

- 페이지: 프로세스의 논리 주소 공간을 자르는 단위
- 프레임: 메모리 물리 주소 공간을 나누는 단위. 페이지와 같은 크기
- 프로세스를 실행하기 위해 프로세스 전체가 메모리에 적재될 필요 없음
- 페이징에서도 페이지 단위로 스와핑을 사용함
  - 페이지 아웃: 메모리 -> 보조기억장치
  - 페이지 인: 보조기억장치 -> 메모리
- 단 여전히 내부 단편화의 문제를 야기할 수 있음
  - 내부 단편화: 페이지라는 일정한 크기 단위로 프로세스를 자를 때 모든 프로세스가 페이지의 배수가 아니므로 마지막 페이지에서 낭비되는 메모리가 발생하는 것
  - 하나의 페이지 크기를 작게하면 발생하는 내부 단편화의 크기가 작아짐
  - 페이지 크기가 너무 작아지면 페이지 테이블의 크기가 커져 페이지 테이블이 차지하는 공간이 낭비됨
  - 대형 페이지: 일부 운영체제에서는 기본적으로 설정된 페이지 크기보다 더 큰 크기의 페이지도 일부 허용하는 경우가 있는데 해당 페이지를 가리키는 말

<br/><br/>

## 페이지 테이블

프로세스가 메모리에 불연속적으로 적재되면 CPU 는 다음 실행할 명령어의 위치를 찾기가 어려워지는데 이를 방지하기 위해 페이지 번호와 프레임 번호를 맵핑하여 나타낸 것

- 프로세스마다 각자의 프로세스 테이블이 있음
- 물리 주소 상에는 프로세스들이 분산되어있어도 논리 주소 상으로는 연속적으로 보임
- 페이지 테이블 베이스 레지스터(PTBR, Page Table Base Register): 각 프로세스들의 페이지 테이블이 적재된 주소를 가리킴
- 각 프로세스들의 페이지 테이블 정보는 각 프로세스의 PCB 에 기록
- TLB(Translation Lookaside Buffer): CPU 가 페이지 테이블을 확인한 후에 프레임에 접근해야 하므로 메모리 접근 시간이 두 배로 늘어남. 이 문제를 해결하기 위해 CPU 곁에(일반적으로 MMU 내에) 두는 페이지 테이블의 캐시 메모리
  - TLB 히트: 논리 주소에 대한 페이지 번호가 TLB 에 있어 메모리에 한 번만 접근하는 경우
  - TLB 미스: 페이지 번호가 TLB 에 없어서 메모리에 두 번 접근하는 경우

<br/><br/>

## 페이징에서의 주소 변환

- 페이징 시스템에서는 논리주소가 페이지 번호와 변위(offset)로 이루어져있음
  - 페이지 번호: 어떤 페이지/프레임에 접근하고 싶은지
  - 변위: 접근하려는 주소가 페이지/프레임으로부터 얼마나 떨어져 있는지

<br/><br/>

## 페이지 테이블 엔트리(PTE, Page Table Entry)

페이지 테이블의 각 행들. 페이지 번호, 프레임 번호 뿐아니라 유효 비트, 보호 비트, 참조 비트, 수정 비트 정보가 저장됨

- 유효 비트: 현재 해당 페이지에 접근 가능하는지 여부. 현재 페이지가 메모리에 적재되어있는지 보조기억장치에 있는지를 알려줌
  - 만약 유효 비트가 0인 페이지로 접근하려고 하면 **페이지 폴트** 라는 예외가 발생함
  - 페이지 폴트 처리 과정
    1. CPU 가 기존 작업 내용 백업
    2. 페이지 폴트 처리 루틴을 실행
    3. 페이지 처리 루틴이 원하는 페이지를 메모리로 가져온 후 유효 비트를 1로 변경
    4. 페이지 폴트 처리 후에 CPU 가 해당 페이지에 접근할 수 있게 됨
- 보호 비트: 해당 페이지가 읽기만 가능한지 쓰기도 가능한지 나타내는 비트.
  - 1비트로 구현시 -> 0: 읽기, 1: 읽기&쓰기
  - 3비트로 구현시 -> 각 비트가 읽기, 쓰기, 실행에 대한 가능 여부를 나타냄(rwx)
- 참조 비트: 페이지에 접근한 적 있는지 여부를 나타냄
- 수정 비트: 페이지에 데이터를 쓴 적 있는지 여부를 나타냄
  - 메모리에서 스왑아웃될 때 보조기억장치에 쓰기 작업을 해야하는지 여부를 판단하기 위해 존재
  - 수정된 적 없는 페이지가 스왑 아웃되면 똑같은 페이지가 보조기억장치에 저장되어 있기 때문에 별도의 추가 작업이 필요 없지만 수정된 적 있는 페이지는 보조기억장치와 다른 값을 가지므로 보조기억장치에 기록하는 작업이 필요

<br/><br/>

### 페이징의 이점 - 쓰기 시 복사

fork 를 진행했을 때 자식 프로세스가 부모 프로세스와 같은 프레임을 가리키게 하여 메모리 공간을 복사하지 않고 동일한 코드 및 데이터 영역을 가리키게함

- 읽기 작업만 발생한다면 해당 상태 지속
- 쓰기 작업이 발생하면 프로세스 간에는 자원을 공유하면 안되므로 쓰기가 발생한 페이지가 별도의 공간으로 복제되고 해당 프레임을 가리키게끔 함
- 프로세스 생성 시간을 줄이고 메모리 공간을 절약할 수 있음

<br/><br/>

### 계층적 페이징(다단계 페이지 테이블)

페이지 테이블을 페이징하여 여러 단계의 페이지를 두는 방식

- 프로세스의 페이지 테이블을 여러 개의 페이지로 자르고 바깥 쪽에 이를 가리키는 페이지 테이블을 다시 둠
- 모든 페이지 테이블을 항상 메모리에 유지할 필요가 없어서 페이지 테이블로 인해 낭비되는 공간을 줄일 수 있음
- (페이지 번호, 변위) 로 구성되어 있던 논리 주소에서 (바깥 페이지 번호, 안쪽 페이지 번호, 변위) 로 구성됨
- 여러 개의 계층을 만들어낼 수 있음. 단, 페이지 폴트 발생 시 메모리 참조 횟수가 많아지므로 계층이 많다고 해서 항상 좋진 않음

<br/><br/><br/><br/>

# 페이지 교체와 프레임 할당

## 요구 페이징

프로세스를 메모리에 적재할 때 필요한 페이지만 메모리에 적재하는 기법

- 순수 요구 페이징 기법: 아무런 페이지도 메모리에 적재하지 않고 실행부터 하는 기법

### 요구 페이징 진행

1. CPU가 특정 페이지에 접근하는 명령어 실행
2. 페이지가 현재 메모리에 있는지 확인(유효비트 확인)

- 있을 경우(유효비트가 1일 경우) CPU 는 페이지가 적재된 프레임에 접근
- 없을 경우(유효비트가 0일 경우) 페이지 폴트 발생시킴 -> 페이지 폴트 처리 루틴을 통해 페이지를 메모리로 적재 후 유효 비트 1로 설정

3. 다시 1번을 수행

<br/><br/>

## 페이지 교체 알고리즘

보조기억장치로 내보낼 페이지를 결정하는 방법. 페이지 폴트를 가장 적게 일으키는 알고리즘이 좋은 알고리즘

- 페이지 참조열: CPU 가 참조한 페이지들 중 연속된 페이지를 생략한 페이지 열(ex. 1 2 2 3 -> 1 2 3)
- 페이지 참조열을 통해 페이지 폴트 횟수를 알 수 있음

### FIFO 페이지 교체 알고리즘

가장 먼저 올라온 페이지부터 내보내는 방식

- 단점: 프로그램 실행 초기에만 실행되는 페이지도 있겠지만 실행 내내 사용되는 페이지일 수도 있음
- 2차 기회 페이지 교체 알고리즘: FIFO 를 기본으로 하되, 참조비트를 참고해서 참조 비트가 0인 경우에는 보조기억 장치로 내보내고 그렇지 않으면 내보내지 않은 뒤 참조 비트를 0으로 바꾸어 한 번의 기회를 더는 방식

### 최적 페이지 교체 알고리즘

앞으로의 사용 빈도가 가장 낮은 페이지를 교체하는 방식으로 가장 합리적임

- 단점: 앞으로의 사용 빈도를 예측하는 것이 어려움. 이론상 성능을 평가할 때만 사용

### LRU 페이지 교체 알고리즘

가장 오랫동안 사용되지 않은 페이지를 교체하는 알고리즘

<br/><br/>

## 스레싱과 프레임 할당

- 프로세스가 사용할 수 있는 레임이 부족 -> 페이지 폴트 자주 발생 -> CPU 이용률 저하
- 스래싱(Thrashing): 프로세스가 실제 실행되는 시간보다 페이징에 더 많은 시간을 소요하여 성능이 저해되는 문제
- 멀티프로그래밍의 정도(Degree of Multiprogramming): 메모리에서 동시에 실행되는 프로세스 수
- 멀티프로그래밍의 정도를 늘린다고 해서 CPU의 이용률이 비례해 증가하지 않음. 어느 정도까지는 증가하다가 스래싱이 발생하기 때문에 급격하게 감소함
- 스래싱을 방지하기 위해 프로세스에게 적절한 프레임을 할당해야 함

### 프레임 할당 방식

- 균등 할당
  - 프로세스 마다 동일한 프레임 수 할당
  - 정적 할당 방식
- 비례 할당
  - 프로세스 크기에 따라 프레임 수를 할당. 실제 실행해보니 크기가 커도 많은 프레임을 필요로 하지 않을 수 있음
  - 정적 할당 방식
- 작업 집합 모델 사용 방식
  - 작업 집합: 프로세스가 일정 시간 동안 참조한 페이지의 집합
  - 작업 집합을 구성하는 원소의 수만큼 프레임을 할당함
  - 동적 할당 방식
- 페이지 폴트 빈도 사용 방식
  - 페이지 폴트 발생의 상한선과 하한선을 정해놓고 상한선을 넘으면 너무 적은 프레임이 할당되었다고 판단 후 프레임을 더 할당하고, 하한선 밑으로 내려가면 너무 많은 프레임이 할당되었다고 판단 후 프레임을 회수함
  - 동적 할당 방식
