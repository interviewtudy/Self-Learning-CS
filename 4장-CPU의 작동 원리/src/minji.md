# ALU와 제어장치

## ALU

- 받아들이는 정보: 레지스터를 통해 피연산자를 받아들이고 제어장치로부터 수행할 연산을 알려주는 제어신호를 받아들임
- 내보내는 정보: 연산 수행 결과(숫자나 문자, 메모리 주소 등)를 레지스터에 저장하고 연산 결과에 대한 추가적인 상태 정보인 플래그를 플래그 레지스터에 저장함
- 가산기, 보수기, 시프터, 오버플로우 검출기 등 계산을 위한 다양한 회로들이 있음

### 플래그

- 부호 플래그: 연산 결과의 부호를 나타냄(1은 음수, 0은 양수)
- 제로 플래그: 연산 결과가 0인지 여부(1은 0이 맞음, 0이면 0이 아님)
- 캐리 플래그: 연산 결과 올림수나 빌림 수가 발생했는지 여부(1이 발생, 0이 미발생)
- 오버플로우 플래그: 오버플로우 발생 여부
- 인터럽트 플래그: 인터럽트가 가능한지 여부
- 슈퍼바이저 플래그: 커널 모드로 실행 중인지, 유저 모드로 실행 중인지(1: 커널모드, 0: 유저모드)

<br/><br/>

## 제어 장치

제어 신호를 내보내고 명령어를 해석하는 부품

### 제어 장치가 받아들임

1. 제어 장치는 클럭 신호를 받아들임

- 클럭(clock): 모든 부품을 일사분란하게 움직일 수 있게하는 시간 단위
- 한 클럭단위로 작동하는 것은 아니고 여러 클럭에 걸쳐 실행 가능

2. 제어 장치는 해석해야할 명령어를 받아들임

- **명령어 레지스터** 로부터 명령어를 받아들이고 해석한 후 제어 신호를 발생시킴

3. 제어장치는 플래그 레지스터 속 플래그 값을 받아들임
4. 제어장치는 시스템 버스 중 제어 버스로 전달된 제어 신호를 받아들임

- CPU 외부 장치에서 발생한 제어 신호를 제어 버스를 통해 받아들임

### 제어 장치가 내보냄

- 메모리에 저장된 값을 읽거나 쓰고 싶다면 메모리로 제어 신호를 내보냄
- 입출력 장치의 값을 읽거나 쓰고 싶다면 입출력장치로 제어 신호를 내보냄
- CPU 내부로 전달하는 신호로는 ALU 에 전달하는 제어 신호와 레지스터에 전달하는 제어 신호가 있고, ALU 에는 수행할 연산을 지시, 레지스터에는 레지스터 간 데이터를 이동시키거나 레지스터에 저장된 명령어를 해석하기 위해 제어 신호를 내보냄

<br/><br/><br/><br/>

# 레지스터

- CPU 마다 이름, 크기, 종류가 다양함

## 레지스터 종류

### 프로그램 카운터(PC, Program Counter)

- 메모리에서 가져올 명령어의 주소를 저장
- 명령어 포인터(IP, Instruction Pointer) 라고 부르는 CPU 도 있음

### 명령어 레지스터(IR, Instruction Register)

- 해석할 명령어, 즉 메모리에서 읽어온 명령어를 저장하는 레지스터

### 메모리 주소 레지스터(MAR, Memory Address Register)

- 메모리의 주소를 저장하는 레지스터
- CPU가 읽어들이고자 하는 주소 값을 주소 버스로 보낼 때 거침

### 메모리 버퍼 레지스터(MBR: Memory Buffer Register)

- 메모리와 주고받을 값(데이터와 명령어)을 저장하는 레지스터
- 메모리에쓰고 싶은 값이나 메모리로부터 전달받은 값들이 거침
- 데이터 버스로 주고 받을 값들이 거침
- 메모리 데이터 레지스터(MDR, Memory Data Register)라고도 함

### 범용 레지스터(General Purpose Register)

- 일반적인 상황에서 자유롭게 사용할 수 잇는 레지스터
- 주소, 데이터 값 모두 저장 가능

### 플래그 레지스터

- ALU 연산 결과에 따른 플래그를 저장하는 레지스터

<br/><br/>

## 스택 주소 지정 방식

스택과 스택 포인터를 이용한 주소 지정 방식

- 스택 포인터: 스택의 꼭대기를 가리키는 레지스터
- 스택 영역: 미모리에서 스택처럼 사용하는 영역

<br/><br/>

## 변위 주소 지정 방식

오퍼랜드의 필드 값(변위)과 특정 레지스터의 값을 더해 유효 주소를 얻어내는 주소 지정 방식

- 연산코드, 레지스터, 오퍼랜드 필드로 구성 되어 있음
- 오퍼랜드 필드의 주소와 어떤 레지스터를 더하는 지에 따라 상대 주소 지정 방식과 베이스 레지스터 주소 지정 방식 등으로 나뉨

### 상대 주소 지정 방식

오퍼랜드와 프로그램 카운터의 값을 더하여 유효 주소를 얻는 방식

- ex. 프로그램 카운터에 100, 오퍼랜드에 -3 이 저장되어 있다면 97 번지로 접근하라는 뜻

### 베이스 레지스터 주소 지정 방식

오퍼랜드와 베이스 레지스터의 값을 더해 유효 주소를 얻는 방식

- 베이스 레지스터가 기존 주소, 오퍼랜드가 기존 주소로부터 떨어진 거리를 표현함
- ex. 베이스 레지스터에 200, 오퍼랜드에 40이 저장되어 있다면 240번지로 접근하라는 뜻

<br/><br/><br/><br/>

# 명령어 사이클과 인터럽트

## 명령어 사이클

프로그램 속 명령어들은 일정한 주기가 반복되며 실행되는데, 이 주기를 의미함

- 인출 사이클(Fetch Cycle): 메모리에 있는 명령어를 CPU로 가져오는 단계
- 실행 사이클(Execution Cycle): 명령어를 실행하는 단계. 제어장치가 명령어 레지스터에 담긴 값을 해석하고 제어 신호를 발생시키는 단계
- 간접 사이클(Indirect Cycle): 간접 주소 지정 방식과 같이 메모리에 한번 더 접근해야 하는 경우, 메모리에 재접근하는 단계
- 인터럽트 사이클: 인터럽트가 발생한 경우 인터럽트를 처리하는 과정
- 인출, 실행 사이클만으로도 실행이 되기도 하고 인출, 간접, 실행 사이클로 실행이되기도 함

## 인터럽트

CPU의 작업을 방해하는 신호

- 동기 인터럽트: CPU에 의해 발생하는 인터럽트
  - CPU가 실행하는 프로그래밍상의 오류와 같은 예외적인 상황에 마주하는 인터럽트를 의미함
  - 예외(Exception)라고도 부름
- 비동기 인터럽트: 입출력 장치에 의해 발생하는 인터럽트
  - 하드웨어 인터럽트라고도 부름

### 하드웨어 인터럽트

효율적으로 명령어를 처리하기 위해 사용

- 입출력 장치의 작동이 끝날 때까지 대기하거나 주기적으로 확인할 필요 없이 완료 여부와도 같은 하드웨어 인터럽트를 CPU 가 수신하기 때문에 그동안 다른 작업을 처리할 수 있음
- 처리 순서
  1. 입출력장치가 CPU에 인터럽트 요청 신호를 보냄
  2. CPU 는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부 확인
  3. 인터럽트 요청을 확인하고 인터럽트 플래그를 통해 현재 인터럽트를 받아들일 수 있는지 여부 확인
  4. 인터럽트를 받아들일 수 있다면 CPU 는 지금까지의 작업을 백업
  5. 인터럽트 벡터를 참조하여 인터럽트 서비스 루틴을 실행
  6. 서비스 루틴 종료 시 4에서 백업해둔 작업ㅇ르 복구하여 실행 재개
- 인터럽트 요청 신호: CPU의 정상적인 실행을 끊을 수 있는지 CPU에 물어보는 것
- 인터럽트 플래그: 플래그 레지스터에 저장된 값으로 이 값에 따라 하드웨어 인터럽트를 받아들일지 여부를 결정함. 하지만 무시할 수 없는 인터럽트 요청도 있음(정전이나 하드웨어 고장과 같은)
- 인터럽트 서비스 루틴: 인터럽트를 처리하기 위한 프로그램으로 인터럽트 핸들러라고도 부름
- 인터럽트 벡터: 인터럽트 서비스 루틴을 식별하기 위한 정보로 이를 통해 인터럽트 서비스 루틴의 시작주소를 알 수 있음
- 인터럽트 서비스 루틴을 실행하기 전에 스택 영역에 모든 내용을 백업함

### 예외의 종류

- 폴트(fault): 예외를 처리한 후 예외가 발생한 명령어부터 실행을 재개
- 트랩(trap): 예외를 처리한 후 예외가 발생한 명령어의 다음 명령어부터 실행을 재개(디버깅 용으로도 사용)
- 중단(abort): 실행중인 프로그램을 강제로 중단시킬 수 밖에 없는 심각한 오류를 발견했을 때 발생하는 예외
- 소프트웨어 인터럽트: 시스템 호출이 발생했을 때 나타남
